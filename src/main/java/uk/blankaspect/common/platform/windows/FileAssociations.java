/*====================================================================*\

FileAssociations.java

Class: Windows file associations.

\*====================================================================*/


// PACKAGE


package uk.blankaspect.common.platform.windows;

//----------------------------------------------------------------------


// IMPORTS


import java.io.File;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.IOException;

import java.nio.file.Files;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.EnumMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import java.util.stream.Collectors;

import uk.blankaspect.common.exception.AppException;
import uk.blankaspect.common.exception.FileException;
import uk.blankaspect.common.exception.TaskCancelledException;

import uk.blankaspect.common.misc.IProcessOutputWriter;
import uk.blankaspect.common.misc.Task;
import uk.blankaspect.common.misc.TextFile;

import uk.blankaspect.common.string.StringUtils;

//----------------------------------------------------------------------


// CLASS: WINDOWS FILE ASSOCIATIONS


public class FileAssociations
{

////////////////////////////////////////////////////////////////////////
//  Constants
////////////////////////////////////////////////////////////////////////

	private static final	int		INDENT_INCREMENT	= 4;
	private static final	int		MAX_LINE_LENGTH		= 72;

	private static final	String	EXTENSION_SEPARATOR			= ",";
	private static final	String	PADDED_EXTENSION_SEPARATOR	= EXTENSION_SEPARATOR + " ";

	private static final	String	SCRIPT_EXTENSION	= ".ps1";

	private static final	String	SCRIPT_EXECUTION_COMMAND	= "powershell";
	private static final	String	SCRIPT_ARG_REMOVE			= "-remove";

	private static final	String	COMMENT_PREFIX	= "#";
	private static final	String	HEADER_PREFIX	= COMMENT_PREFIX + " ";

	private static final	int		HEADER_WRAP_LENGTH	= MAX_LINE_LENGTH - HEADER_PREFIX.length();

	private static final	String	WRITING_STR		= "Writing ";
	private static final	String	EXECUTING_STR	= "Executing ";
	private static final	String	DELETING_STR	= "Deleting ";
	private static final	String	SUCCESS_STR		= "The operation was completed successfully.\n";
	private static final	String	ERROR_STR		= "! ERROR !\n";

	private static final	String	HEADER_COMMENT1	= "This Windows PowerShell script was automatically generated by "
														+ "the %s application to add and remove Windows Registry "
														+ "entries that associate the following filename extension(s) "
														+ "with the application:";
	private static final	String	HEADER_COMMENT2	= "To remove the associations, run this script with the "
														+ "command-line argument '-remove'.";

	private static final	List<String>	SCRIPT_FRAGMENT1	= Arrays.asList
	(
		"param",
		"(",
		"[switch]$remove = $false",
		")",
		"",
		"$registryRoot  = \"Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\"",
		"$defaultKey    = \"(default)\"",
		"$extensionsKey = \"Extensions\"",
		"",
		"$java = \"%s\"",
		"$jar  = \"%s\"",
		"$icon = \"%s\"",
		"",
		"$valueType =",
		"@{",
		"string       = \"String\"",
		"expandString = \"ExpandString\"",
		"}",
		"",
		"$paramSets ="
	);
	private static final	List<String>	SCRIPT_FRAGMENT2	= Arrays.asList
	(
		"",
		"function splitExtensions($extensions)",
		"{",
		"return $extensions.split(\",\")",
		"}",
		"",
		"function createKeyMap($params)",
		"{",
		"$path = Join-Path -Path $registryRoot -ChildPath $params.fileKindKey",
		"[Collections.ArrayList]$keyMap =",
		"@(",
		"@(",
		"$path,",
		"@(),",
		"$true,",
		"$defaultKey,",
		"$params.fileKindText,",
		"$valueType.string",
		"),",
		"@(",
		"$path,",
		"@(),",
		"$false,",
		"$extensionsKey,",
		"$params.extensions,",
		"$valueType.string",
		"),",
		"@(",
		"$path,",
		"@(\"DefaultIcon\"),",
		"$false,",
		"$defaultKey,",
		"\"\"\"$icon\"\"\",",
		"$valueType.expandString",
		"),",
		"@(",
		"$path,",
		"@(\"shell\", \"open\"),",
		"$false,",
		"$defaultKey,",
		"$params.fileOpenText,",
		"$valueType.string",
		"),",
		"@(",
		"$path,",
		"@(\"shell\", \"open\", \"command\"),",
		"$false,",
		"$defaultKey,",
		"\"\"\"$java\"\" -jar \"\"$jar\"\" \"\"%s\"\"\",",
		"$valueType.expandString",
		")",
		")",
		"",
		"foreach ($extension in splitExtensions $params.extensions)",
		"{",
		"$path = Join-Path -Path $registryRoot -ChildPath $extension",
		"[void]$keyMap.Add(@($path, @(), $true, $defaultKey, $params.fileKindKey, $valueType.string))",
		"}",
		"return $keyMap",
		"}",
		"",
		"foreach ($params in $paramSets)",
		"{",
		"# Remove entries for old extensions",
		"$path = Join-Path -Path $registryRoot -ChildPath $params.fileKindKey",
		"if (Test-Path -Path $path)",
		"{",
		"$extensions = (Get-ItemProperty -Path $path).$extensionsKey",
		"if ($extensions)",
		"{",
		"foreach ($extension in splitExtensions $extensions)",
		"{",
		"$path = Join-Path -Path $registryRoot -ChildPath $extension",
		"if (Test-Path -Path $path)",
		"{",
		"Remove-Item -Path $path -Recurse",
		"}",
		"}",
		"}",
		"}",
		"",
		"# Add an entry for each file kind and extension",
		"foreach ($entry in createKeyMap $params)",
		"{",
		"# Concatenate path",
		"$path = $entry[0]",
		"foreach ($p in $entry[1])",
		"{",
		"$path = Join-Path -Path $path -ChildPath $p",
		"}",
		"",
		"# Remove existing entry",
		"if ($entry[2] -and (Test-Path -Path $path))",
		"{",
		"Remove-Item -Path $path -Recurse",
		"}",
		"",
		"# Add entry",
		"if (-not $remove)",
		"{",
		"if (-not (Test-Path -Path $path))",
		"{",
		"New-Item -Path $path -Force > $null",
		"}",
		"New-ItemProperty -Path $path -Name $entry[3] -Value $entry[4] -PropertyType $entry[5] > $null",
		"}",
		"}",
		"}"
	);

////////////////////////////////////////////////////////////////////////
//  Enumerated types
////////////////////////////////////////////////////////////////////////


	// ENUMERATION: SCRIPT LIFE CYCLE


	public enum ScriptLifeCycle
	{

	////////////////////////////////////////////////////////////////////
	//  Constants
	////////////////////////////////////////////////////////////////////

		WRITE
		(
			"Write"
		),

		WRITE_EXECUTE
		(
			"Write and execute"
		),

		WRITE_EXECUTE_DELETE
		(
			"Write, execute and delete"
		);

	////////////////////////////////////////////////////////////////////
	//  Instance variables
	////////////////////////////////////////////////////////////////////

		private	String	text;

	////////////////////////////////////////////////////////////////////
	//  Constructors
	////////////////////////////////////////////////////////////////////

		private ScriptLifeCycle(String text)
		{
			this.text = text;
		}

		//--------------------------------------------------------------

	////////////////////////////////////////////////////////////////////
	//  Instance methods : overriding methods
	////////////////////////////////////////////////////////////////////

		@Override
		public String toString()
		{
			return text;
		}

		//--------------------------------------------------------------

	}


	//==================================================================


	// ENUMERATION: FILE-KIND PARAMETERS


	private enum FileKindParam
	{

	////////////////////////////////////////////////////////////////////
	//  Constants
	////////////////////////////////////////////////////////////////////

		FILE_KIND_KEY
		(
			"fileKindKey"
		),

		FILE_KIND_TEXT
		(
			"fileKindText"
		),

		FILE_OPEN_TEXT
		(
			"fileOpenText"
		),

		EXTENSIONS
		(
			"extensions"
		);

		//--------------------------------------------------------------

		private static final	int	MAX_KEY_LENGTH;

	////////////////////////////////////////////////////////////////////
	//  Static initialiser
	////////////////////////////////////////////////////////////////////

		static
		{
			int maxLength = 0;
			for (FileKindParam value : values())
			{
				int length = value.key.length();
				if (maxLength < length)
					maxLength = length;
			}
			MAX_KEY_LENGTH = maxLength;
		}

	////////////////////////////////////////////////////////////////////
	//  Instance variables
	////////////////////////////////////////////////////////////////////

		private	String	key;

	////////////////////////////////////////////////////////////////////
	//  Constructors
	////////////////////////////////////////////////////////////////////

		private FileKindParam(String key)
		{
			this.key = key;
		}

		//--------------------------------------------------------------

	}

	//==================================================================


	// ENUMERATION: ERROR IDENTIFIERS


	private enum ErrorId
		implements AppException.IId
	{

	////////////////////////////////////////////////////////////////////
	//  Constants
	////////////////////////////////////////////////////////////////////

		FAILED_TO_CREATE_TEMPORARY_DIRECTORY
		("Failed to create a temporary directory."),

		FAILED_TO_EXECUTE_SCRIPT
		("Failed to execute the script."),

		ERROR_EXECUTING_SCRIPT
		("An error occurred when executing the script."),

		FAILED_TO_DELETE_SCRIPT_FILE
		("Failed to delete the script file."),

		FAILED_TO_DELETE_TEMPORARY_DIRECTORY
		("Failed to delete the temporary directory.");

	////////////////////////////////////////////////////////////////////
	//  Instance variables
	////////////////////////////////////////////////////////////////////

		private	String	message;

	////////////////////////////////////////////////////////////////////
	//  Constructors
	////////////////////////////////////////////////////////////////////

		private ErrorId(String message)
		{
			this.message = message;
		}

		//--------------------------------------------------------------

	////////////////////////////////////////////////////////////////////
	//  Instance methods : AppException.IId interface
	////////////////////////////////////////////////////////////////////

		@Override
		public String getMessage()
		{
			return message;
		}

		//--------------------------------------------------------------

	}

	//==================================================================

////////////////////////////////////////////////////////////////////////
//  Member classes : non-inner classes
////////////////////////////////////////////////////////////////////////


	// CLASS: PROCESS OUTPUT HANDLER


	private static class ProcessOutputHandler
		implements Runnable
	{

	////////////////////////////////////////////////////////////////////
	//  Constants
	////////////////////////////////////////////////////////////////////

		private static final	int	BUFFER_SIZE	= 512;

	////////////////////////////////////////////////////////////////////
	//  Instance variables
	////////////////////////////////////////////////////////////////////

		private	InputStreamReader		reader;
		private	IProcessOutputWriter	writer;
		private	char[]					buffer;
		private	boolean					stopRequested;

	////////////////////////////////////////////////////////////////////
	//  Constructors
	////////////////////////////////////////////////////////////////////

		private ProcessOutputHandler(InputStream          inStream,
									 IProcessOutputWriter writer)
		{
			reader = new InputStreamReader(inStream);
			this.writer = writer;
			buffer = new char[BUFFER_SIZE];
		}

		//--------------------------------------------------------------

	////////////////////////////////////////////////////////////////////
	//  Instance methods : Runnable interface
	////////////////////////////////////////////////////////////////////

		@Override
		public void run()
		{
			boolean done = false;
			while (!done)
			{
				// Allow other threads to run
				Thread.yield();

				// Display output from process
				try
				{
					while (reader.ready())
					{
						int length = reader.read(buffer, 0, buffer.length);
						if ((length > 0) && (writer != null))
							writer.write(new String(buffer, 0, length));
					}
				}
				catch (IOException e)
				{
					// ignore
				}

				// Respond to a request to stop
				if (stopRequested)
					done = true;
			}
		}

		//--------------------------------------------------------------

	////////////////////////////////////////////////////////////////////
	//  Instance methods
	////////////////////////////////////////////////////////////////////

		private void stop()
		{
			stopRequested = true;
		}

		//--------------------------------------------------------------

	}

	//==================================================================

////////////////////////////////////////////////////////////////////////
//  Instance variables
////////////////////////////////////////////////////////////////////////

	private	List<Map<FileKindParam, String>>	fileKindParams;

////////////////////////////////////////////////////////////////////////
//  Constructors
////////////////////////////////////////////////////////////////////////

	public FileAssociations()
	{
		fileKindParams = new ArrayList<>();
	}

	//------------------------------------------------------------------

////////////////////////////////////////////////////////////////////////
//  Class methods
////////////////////////////////////////////////////////////////////////

	public static String escapeDoubleQuotes(String str)
	{
		return str.replace("\"", "\"\"");
	}

	//------------------------------------------------------------------

	public static void appendLines(StringBuilder buffer,
								   List<String>  lines,
								   Object...     replacements)
	{
		int indent = 0;
		String spaces = "";
		for (String line : lines)
		{
			if (replacements.length > 0)
				line = String.format(line, replacements);

			if (line.startsWith(")") || line.startsWith("}"))
				indent -= INDENT_INCREMENT;
			if (!line.isEmpty())
			{
				if (spaces.length() < indent)
					spaces = " ".repeat(indent);
				buffer.append(spaces, 0, indent);
			}
			buffer.append(line);
			buffer.append('\n');
			if (line.endsWith("(") || line.endsWith("{"))
				indent += INDENT_INCREMENT;
		}
	}

	//------------------------------------------------------------------

	private static void executeProcess(List<String>         arguments,
									   IProcessOutputWriter outWriter)
		throws AppException
	{
		// Start process
		Process process = null;
		try
		{
			ProcessBuilder processBuilder = new ProcessBuilder(arguments);
			processBuilder.redirectErrorStream(true);
			process = processBuilder.start();
		}
		catch (IOException e)
		{
			throw new AppException(ErrorId.FAILED_TO_EXECUTE_SCRIPT, e);
		}

		// Create thread to handle output from process
		ProcessOutputHandler outputHandler = new ProcessOutputHandler(process.getInputStream(), outWriter);
		Thread outputThread = new Thread(outputHandler);
		outputThread.start();

		// Wait for process to terminate
		try
		{
			while (true)
			{
				// Test whether task has been cancelled
				if (Task.isCancelled())
				{
					process.destroy();
					throw new TaskCancelledException();
				}

				// Allow process to execute
				try
				{
					Thread.sleep(100);
				}
				catch (InterruptedException e)
				{
					// ignore
				}

				// Test whether process has terminated
				try
				{
					int exitValue = process.exitValue();
					if (exitValue != 0)
						throw new AppException(ErrorId.ERROR_EXECUTING_SCRIPT);
					break;
				}
				catch (IllegalThreadStateException e)
				{
					// ignore
				}
			}
		}
		catch (AppException e)
		{
			throw e;
		}
		finally
		{
			// Stop output handler and wait for output thread to finish
			outputHandler.stop();
			while (outputThread.isAlive())
				Thread.yield();
		}
	}

	//------------------------------------------------------------------

	private static String wrapHeader(String header)
	{
		return StringUtils.wrapLines(header, HEADER_WRAP_LENGTH).stream()
												.collect(Collectors.joining("\n" + HEADER_PREFIX, HEADER_PREFIX, "\n"));
	}

	//------------------------------------------------------------------

////////////////////////////////////////////////////////////////////////
//  Instance methods
////////////////////////////////////////////////////////////////////////

	public void addParams(String    fileKindKey,
						  String    fileKindText,
						  String    fileOpenText,
						  String... extensions)
	{
		addParams(fileKindKey, fileKindText, fileOpenText, Arrays.asList(extensions));
	}

	//------------------------------------------------------------------

	public void addParams(String       fileKindKey,
						  String       fileKindText,
						  String       fileOpenText,
						  List<String> extensions)
	{
		Map<FileKindParam, String> map = new EnumMap<>(FileKindParam.class);
		map.put(FileKindParam.FILE_KIND_KEY,  fileKindKey);
		map.put(FileKindParam.FILE_KIND_TEXT, fileKindText);
		map.put(FileKindParam.FILE_OPEN_TEXT, fileOpenText);
		map.put(FileKindParam.EXTENSIONS,     String.join(EXTENSION_SEPARATOR, extensions));
		fileKindParams.add(map);
	}

	//------------------------------------------------------------------

	public String createScript(String appName,
							   String javaLauncherPathname,
							   String jarPathname,
							   String iconPathname)
	{
		// Append header comment
		StringBuilder buffer = new StringBuilder(4096);
		buffer.append(wrapHeader(String.format(HEADER_COMMENT1, appName)));
		buffer.append(HEADER_PREFIX);
		int startIndex = buffer.length();
		for (Map<FileKindParam, String> params : fileKindParams)
		{
			if (buffer.length() > startIndex)
				buffer.append(PADDED_EXTENSION_SEPARATOR);
			buffer.append(params.get(FileKindParam.EXTENSIONS).replace(EXTENSION_SEPARATOR,
																	   PADDED_EXTENSION_SEPARATOR));
		}
		buffer.append('\n');
		buffer.append(COMMENT_PREFIX);
		buffer.append('\n');
		buffer.append(wrapHeader(HEADER_COMMENT2));
		buffer.append('\n');

		// Append script fragment
		appendLines(buffer, SCRIPT_FRAGMENT1, javaLauncherPathname, jarPathname, iconPathname);

		// Append parameters
		List<String> lines = new ArrayList<>();
		lines.add("@(");
		Iterator<Map<FileKindParam, String>> it = fileKindParams.iterator();
		while (it.hasNext())
		{
			lines.add("@{");
			Map<FileKindParam, String> params = it.next();
			for (FileKindParam param : FileKindParam.values())
				lines.add(StringUtils.padAfter(param.key, FileKindParam.MAX_KEY_LENGTH) + " = \""
																		+ escapeDoubleQuotes(params.get(param)) + "\"");
			lines.add(it.hasNext() ? "}," : "}");
		}
		lines.add(")");
		appendLines(buffer, lines);

		// Append script fragment
		appendLines(buffer, SCRIPT_FRAGMENT2);

		return buffer.toString();
	}

	//------------------------------------------------------------------

	public File executeScript(String               appName,
							  String               javaLauncherPathname,
							  String               jarPathname,
							  String               iconPathname,
							  String               tempDirectoryPrefix,
							  String               scriptFilename,
							  boolean              removeEntries,
							  ScriptLifeCycle      scriptLifeCycle,
							  IProcessOutputWriter outWriter)
		throws AppException
	{
		File tempDirectory = null;
		File scriptFile = null;
		try
		{
			// Create temporary directory
			try
			{
				tempDirectory = Files.createTempDirectory(tempDirectoryPrefix).toFile();
			}
			catch (Exception e)
			{
				throw new AppException(ErrorId.FAILED_TO_CREATE_TEMPORARY_DIRECTORY, e);
			}

			// Get pathname of script file
			if (!scriptFilename.endsWith(SCRIPT_EXTENSION))
				scriptFilename += SCRIPT_EXTENSION;
			scriptFile = new File(tempDirectory, scriptFilename);

			// Delete script file and temporary directory when the program exits
			if (scriptLifeCycle == ScriptLifeCycle.WRITE_EXECUTE_DELETE)
			{
				tempDirectory.deleteOnExit();
				scriptFile.deleteOnExit();
			}

			// Write status message
			if (outWriter != null)
				outWriter.write(WRITING_STR + scriptFile.toString() + "\n");

			// Write script file to temporary directory
			TextFile.write(scriptFile, createScript(appName, javaLauncherPathname, jarPathname, iconPathname));

			// Execute script
			if (scriptLifeCycle != ScriptLifeCycle.WRITE)
			{
				// Write status message
				if (outWriter != null)
					outWriter.write(EXECUTING_STR + scriptFilename + "\n");

				// Execute script
				List<String> arguments = new ArrayList<>();
				arguments.add(SCRIPT_EXECUTION_COMMAND);
				arguments.add(scriptFile.toString());
				if (removeEntries)
					arguments.add(SCRIPT_ARG_REMOVE);
				executeProcess(arguments, outWriter);
			}

			// Delete script file and temporary directory
			if (scriptLifeCycle == ScriptLifeCycle.WRITE_EXECUTE_DELETE)
			{
				// Write status message
				if (outWriter != null)
					outWriter.write(DELETING_STR + scriptFilename + "\n");

				// Delete script file
				if (!scriptFile.delete())
					throw new FileException(ErrorId.FAILED_TO_DELETE_SCRIPT_FILE, scriptFile);

				// Delete temporary directory
				if (!tempDirectory.delete())
					throw new FileException(ErrorId.FAILED_TO_DELETE_TEMPORARY_DIRECTORY, tempDirectory);
			}

			// Report success
			if (outWriter != null)
				outWriter.write(SUCCESS_STR);
		}
		catch (AppException e)
		{
			// Delete script file and temporary directory
			if (scriptLifeCycle == ScriptLifeCycle.WRITE_EXECUTE_DELETE)
			{
				if (scriptFile != null)
					scriptFile.delete();
				if (tempDirectory != null)
					tempDirectory.delete();
			}

			// Rethrow exception
			if (outWriter == null)
				throw e;

			// Write error message to output
			if (!(e instanceof TaskCancelledException))
			{
				outWriter.write(ERROR_STR);
				outWriter.write(e.toString());
			}
		}
		finally
		{
			// Close output writer and wait for it to close
			if (outWriter != null)
			{
				outWriter.close();
				while (!outWriter.isClosed())
					Thread.yield();
			}
		}

		// Return location of script file
		return ((scriptLifeCycle == ScriptLifeCycle.WRITE_EXECUTE_DELETE) ? null : scriptFile);
	}

	//------------------------------------------------------------------

}

//----------------------------------------------------------------------
